<?phpnamespace App\Service\KB;use App\KnowBase;use App\Models\KnowBaseModel;use App\Position;use App\ProfileGroup;use App\User;class KnowBaseService{    public array $accessible_kb_ids = [];    public function __construct()    {        $this->accessible_kb_ids = $this->getBooks();    }    public static function getAll()    {        return KnowBase::with([            'onlyChildren:id,parent_id,is_category,order,title'        ])->select('id', 'parent_id', 'is_category', 'order', 'title')->get();    }    public function buildTree()    {        $items = self::getAll();        $itemsById = $items->keyBy('id');        foreach ($items as $item) {            if (!is_null($item->parent_id) && isset($itemsById[$item->parent_id])) {                $parent = $itemsById[$item->parent_id];                $parent->onlyChildren = $parent->onlyChildren ?? collect();                $index = $parent->onlyChildren->search(function ($child) use ($item) {                    return $child->id === $item->id;                });                if ($index !== false) {                    // Remove item if exists in relation, because We have item with its relation and should push this item and avoiding duplicating                    $parent->onlyChildren = $parent->onlyChildren->filter(function ($child) use ($item) {                        return $child->id !== $item->id;                    })->values();                }                $parent->onlyChildren->push($item);                $parent->onlyChildren = $parent->onlyChildren->sortBy('order');            }        }        $tree = $items->sortBy('order')->filter(function ($item) {            return is_null($item->parent_id);        })->values();//        return $tree;//        dd($this->filterTree($tree)[0]->onlyChildren);        return $this->filterAndRestructureTree($tree, $this->accessible_kb_ids);    }    private function buildTree2(&$flatNodes, $parentId = null, $accessibleIds, &$builtIds = []) {        $tree = [];        foreach ($flatNodes as $id => $node) {            if ($node['parent_id'] == $parentId && !in_array($id, $builtIds)) {                if (in_array($node['id'], $accessibleIds)) {                    // If the user has access, add the node and its children to the tree                    $builtIds[] = $id; // Mark this node as built                    $node['children'] = $this->buildTree2($flatNodes, $node['id'], $accessibleIds, $builtIds);                    $tree[] = $node;                } else {                    // If the user doesn't have access, skip adding this node directly                    // Instead, attempt to add its children to the current level if accessible                    $children = $this->buildTree2($flatNodes, $node['id'], $accessibleIds, $builtIds);                    foreach ($children as $child) {                        // Add accessible children directly under the current node's parent                        if (in_array($child['id'], $accessibleIds)) {                            $tree[] = $child;                        }                    }                }            }        }        return $tree;    }    public function filterAndRestructureTree($allNodes, $accessibleIds) {        // Convert the array of nodes into a flat map for easy access        $flatNodes = [];        foreach ($allNodes as $node) {            $flatNodes[$node['id']] = $node;        }        // Start building the tree from the root        return $this->buildTree2($flatNodes, null, $accessibleIds);    }    private function filterTree($tree, $parentAccess = true)    {        return $tree->map(function ($node) use ($parentAccess) {            $hasAccess = ($node->is_category == 1 || $node->parent_id == null) ? $this->hasAccess($node->id) : $parentAccess;            if ($node->onlyChildren->isNotEmpty()) {                $node['onlyChildren'] = $this->filterTree(collect($node['onlyChildren']), $hasAccess);                // If it's a category without access, but has children with access, we still include it.                if ($node['is_category'] == 1 && !$hasAccess && $node['children']->isEmpty()) {                    return null;                }            } else if ($node['is_category'] == 1 && !$hasAccess) {                // If it's a category without access and doesn't have children, we exclude it.                return null;            }            return $node;        })->filter()->values(); // Remove null values and reset keys    }    private function processNode($node, $parentAccess = false, $closestAccessibleParent = null) {        // Determine access for the current node        $nodeAccess = ($node->is_category == 1 || $node->parent_id == null) ? $this->hasAccess($node->id) : $parentAccess;        // Update the closest accessible parent if the current node has access        if ($nodeAccess) {            $closestAccessibleParent = $node;        }        // Process children nodes if any        if ($node->onlyChildren->isNotEmpty()) {            $node->onlyChildren = $node->onlyChildren->map(function ($child) use ($nodeAccess, $closestAccessibleParent) {                // Recursive call to process each child, passing the current access status and closest accessible parent                return $this->processNode($child, $nodeAccess, $closestAccessibleParent);            })->values();        }        // If the node should be moved (based on your conditions, e.g., if it has access but its parent does not),        // and there's a closest accessible parent found, you would then move this node to that parent's children.        // Note: Implementing the actual move logic depends on your data structure and how you manage references within your tree.        return $node; // Return the processed node    }    public function test($tree) {        // Assuming $tree is a collection of top-level nodes        return $tree->map(function ($node) {            // Start processing each top-level node without initial parent access and without a known closest accessible parent            return $this->processNode($node);        });    }    private function test2($tree)    {        return $tree->filter(function ($node) { // HR Department            $parentAccess = ($node->is_category == 1 || $node->parent_id == null) ? $this->hasAccess($node->id) : false;            if ($node->onlyChildren->isNotEmpty()) {                $node->onlyChildren = $node->onlyChildren->filter(function ($child) use (&$node, $parentAccess){ // Отдел Обучения                    $childAccess = ($child->is_category == 1 || $child->parent_id == null) ? $this->hasAccess($child->id) : $parentAccess;                    if ($child->onlyChildren->isNotEmpty()) {                        $child->onlyChildren = $child->onlyChildren->filter(function ($grandson) use (&$node, $childAccess){ // (HR) Как обучать стажеров - операторов                            $grandsonAccess = ($grandson->is_category == 1 || $grandson->parent_id == null) ? $this->hasAccess($grandson->id) : $childAccess;                            if ($grandsonAccess && !$childAccess && $grandson->onlyChildren->isNotEmpty()) {                                $node->onlyChildren->push($grandson); // Marked line                            }                            return $grandsonAccess;                        })->values();                    }                    return $childAccess;                })->values();            }            return $parentAccess;        });    }    /**     * This function might be used filter all tree by checking user permissions...((     */    public function filterTree2($tree, &$accessibleParents = null)    {        if (is_null($accessibleParents)) {            $accessibleParents = collect();        }        foreach ($tree as $key => $node) {            if (!$this->hasAccess($node->id) && ($node->is_category == 1 || $node->parent_id == null)) {                $node->can_view = false;//                dd($node);                if (!empty($node->onlyChildren)) {                    $this->filterTree($node->onlyChildren, $accessibleParents);                }            } else {                $node->can_view = true;                if (!empty($node->onlyChildren)) {                    $node->onlyChildren = $this->filterTree($node->onlyChildren)->sortBy('order');                }                $accessibleParents->push($node);            }        }        return $accessibleParents->sortBy('order')->values();    }    public function hasAccess($itemId): bool    {        $can_read = false;        if (auth()->user()->can('kb_edit')) {            $can_read = true;        } else if (in_array($itemId, $this->accessible_kb_ids)) {            $can_read = true;        }        return $can_read;    }    /**     * Get knowbase ids that user can see     */    private function getBooks($access = 0): array    {        /** @var User $auth_user */        $auth_user = auth()->user();        $books = [];        if ($auth_user->is_admin == 1) {            $books = KnowBase::query()                ->whereNull('parent_id')                ->orWhere('is_category', 1)                ->get('id')                ->pluck('id')                ->toArray();        } else {            $employee_groups = $auth_user->inGroups()->pluck('id')->toArray();            $supervisor_groups = $auth_user->inGroups(true)->pluck('id')->toArray();            $group_ids = array_unique(array_merge($employee_groups, $supervisor_groups));            $position_id = $auth_user->position_id;            $user_id = auth()->id();            $up = KnowBaseModel::query()                ->where(function ($query) use ($group_ids, $access) {                    $query->where('model_type', 'App\\ProfileGroup')                        ->whereIn('model_id', $group_ids);                    if ($access == 2) $query->where('access', 2);                })                ->orWhere(function ($query) use ($position_id, $access) {                    $query->where('model_type', 'App\\Position')                        ->where('model_id', $position_id);                    if ($access == 2) $query->where('access', 2);                })                ->orWhere(function ($query) use ($user_id, $access) {                    $query->where('model_type', 'App\\User')                        ->where('model_id', $user_id);                    if ($access == 2) $query->where('access', 2);                });            $up = $up->get('book_id')                ->pluck('book_id')                ->toArray();            $books = array_merge($books, $up);            $readOrEditPairs = [];            foreach ($group_ids as $group_id) {                $readOrEditPairs[] = ['position_id' => $auth_user->position_id, 'group_id' => $group_id];            }            $books_with_read_access = KnowBase::withTrashed()                ->where(fn($query) => $query->whereNull('parent_id')->orWhere('is_category', 1))                ->whereIn('access', $access == 2 ? [2] : [1, 2])                ->orWhere(function ($query) use ($readOrEditPairs) {                    if (count($readOrEditPairs) > 0) {                        $query->whereJsonContains('read_pairs', $readOrEditPairs[0]);                        foreach ($readOrEditPairs as $pair) {                            $query->orWhereJsonContains('read_pairs', $pair);                        }                    }                })                ->orWhere(function ($query) use ($readOrEditPairs) {                    if (count($readOrEditPairs) > 0) {                        $query->whereJsonContains('edit_pairs', $readOrEditPairs[0]);                        foreach ($readOrEditPairs as $pair) {                            $query->orWhereJsonContains('edit_pairs', $pair);                        }                    }                })                ->get('id')->pluck('id')                ->toArray();            $books = array_merge($books, $books_with_read_access);        }        return $books;    }    private function getWhoCanReadOrEdit($book_id, $access = 'read'): array    {        $can = [];        $items = KnowBaseModel::where([            'book_id' => $book_id,            'access' => $access == 'edit' ? 2 : 1        ])->get();        foreach ($items as $key => $item) {            $arr = [];            $arr['id'] = $item['model_id'];            if ($item->model_type == 'App\\User') {                $arr['type'] = 1;                $user = User::withTrashed()->find($item->model_id);                if (!$user) continue;                $arr['name'] = $user->last_name . ' ' . $user->name;            }            if ($item->model_type == 'App\\ProfileGroup') {                $arr['type'] = 2;                $group = ProfileGroup::find($item->model_id);                if (!$group) continue;                $arr['name'] = $group->name;            }            if ($item->model_type == 'App\\Position') {                $arr['type'] = 3;                $pos = Position::find($item->model_id);                if (!$pos) continue;                $arr['name'] = $pos->position;            }            $can[] = $arr;        }        return $can;    }}